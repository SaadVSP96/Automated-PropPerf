%This code employs the BET to model the propeller efficiency and the
%thrust, torque and power generated by the propeller. The plan is to
%initially recreate the results given by the excel files created by
%S.Gudmundson and then proceed to replace the data by owr own propeller
%should the data become available.
clc;clear variables;close all
%The solution as prepared here breaks the propeller blades into 20 elements
%of equal width. Let’s begin the procedure by calculating some preliminaries:

%Establishing atmospheric Parameters
alt_ft = 1000:1000:50000;%limit is 36K 
alt_m = alt_ft * 0.3048;
%Temp in K, Sound Speed in m/s, Pressure in Pa, rho in kg/m3
[T_si,a_si,P_si,rho_si] = atmoscoesa(alt_m);
%converting atmospheric values to english units
T_eng = 1.8*T_si; %Temperature in English 
a = 3.28084*a_si; %speed of sound in english
P = 0.02088547*P_si;%Pressure in english
rho = 0.00194032*rho_si;%density in english
mew = ((-2.05e-09).*(alt_ft/1000)) + 3.739e-07;%Dynamic Viscoscity curvefit
%Specifying all of the Mach Numbers
Machs = 0.01:0.01:1.0;

%Basic Data
Scale_factor = 1;%scale prop geometry roughly
V_0_fts = 40*1.46667;%mph to ft/s
RPM = 6000;
Dia_prop = 11.01*2*Scale_factor;%inches
Dia_hub = 3.13*2*Scale_factor;%inches
alt_op = 1;% n*1000 ft
a_alt = a(alt_op);

%Preliminaries
n = RPM/60;%rps
Omega = 2*pi*(RPM/60);%rad/s
R_hub = (Dia_hub/2)*(1/12);%ft
R = (Dia_prop/2)*(1/12);%ft
n_blades = 2;
%column 1 which was just serial id's is omitted since the set of
%stations and chords are available from the get go
r = [0.261075000000000,0.269416667000000,0.277758333000000,0.286100000000000,0.294441667000000,0.302783333000000,0.311125000000000,0.319466667000000,0.343108333000000,0.424558333000000,0.506575000000000,0.588591667000000,0.670616667000000,0.752633333000000,0.834650000000000,0.887200000000000,0.895783333000000,0.902225000000000,0.907775000000000,0.913333333000000,0.916666667000000]*Scale_factor;
no_elements = length(r);%no. of elements the prop is divided in
del_r = r(7)-r(6);%ft - the value seems to be equal between all successive elements
%Column 3 is calculated to allow plotting of results with respect to the 
%fraction of the blade span
x = r./R;
%Column 4 is the chord at the radial
c = [0.154758333000000,0.153750000000000,0.152725000000000,0.151675000000000,0.150616667000000,0.149533333000000,0.148441667000000,0.147333333000000,0.144091667000000,0.132025000000000,0.118516667000000,0.103733333000000,0.0877583330000000,0.0706583330000000,0.0525083330000000,0.0404416670000000,0.0378500000000000,0.0338333330000000,0.0279333330000000,0.0146583330000000,0.00166666700000000]*Scale_factor;
%Column 5 is the area of the blade element
for i = 1:1:length(r)
    %Column 5 is the area of the blade element
    del_A(i) = c(i)*del_r;
    %Column 6 is the forward speed (i.e. the airplane’s airspeed) converted to 
    %ft/s and is equal for all the rows
    V_o(i) = V_0_fts;
    %Column 7 is the blade’s tangential rotational speed at that segement
    Omega_x_r(i) = Omega*r(i);
    %Column 8 is the resultant velocity for each segment that combines rotation
    %and forward speed
    V_R(i) = sqrt((V_o(i)^2)+(Omega_x_r(i)^2));
    %Column 9 is the Mach Number for each blade segement - some differences may
    %occur due to inaccuracies in the density or a matrices
    M(i) = V_R(i)/a_alt;
    %Columns 10 and 11 contain the helix angle in radians and degrees
    phi_rad(i) = atan(V_o(i)/Omega_x_r(i));
    phi_deg(i) = rad2deg(phi_rad(i));
    %Columns 12 and 13 contain the induced flow angle, ai, ahead of the 
    %propeller, which reduces the overall AOA on the blade element
    alpha_i_rad(i) = 0;
    alpha_i_deg(i) = rad2deg(alpha_i_rad(i));
end
%Columns 14 and 15 contain the geometric pitch angle B which is specified
%in the file
Beta_deg = [24.2160000000000,23.5916000000000,22.9985000000000,22.4346000000000,21.8978000000000,21.3862000000000,20.8981000000000,20.4320000000000,19.2185000000000,15.9691000000000,13.6722000000000,11.9744000000000,10.6499000000000,9.57880000000000,8.68530000000000,8.96700000000000,9.39440000000000,9.81320000000000,10.2428000000000,10.7418000000000,6.60260000000000];
Beta_rad = deg2rad(Beta_deg);
%now we need the AOA at each segment and of course that uses the formula:
%alpha = Beta - phi - alpha_i + alpha_ZL
%now in the example, it has been stated that the example propeller uses a
%single airfoil and so the zero lift AOA will remain the same trough out
%however we will probably have a more complicated scenario with different
%airfoils at different segments and thereby causing different zerolift
%AOAs, in which case, a set will have to be populated for this manually:
%for now use the sigular example value in all positions
zero_lift_aoa = 0;%deg
alpha_zl_deg = ones(1,no_elements)*(zero_lift_aoa);
alpha_zl_rad = deg2rad(alpha_zl_deg);
%Columns 19 and 20 will contain the C_l and C_d values of the airfoil
%section of the segment in question against the Alpha calculated apriori. 
%For now we assumed that there is only one airfoil making up the whole prop
%but later on we will have 2x the number of airfoils that make up the
%propeller
%inport this data from XFLR5 against the analysis of the CLARKY airfoil at
%the average reynold number and the Mach at the nearest index to that
%Reynolds number
alpha_data = [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,42,59];
C_l_data = [-0.331500000000000,-0.332600000000000,-0.345200000000000,-0.427500000000000,-0.435000000000000,-0.456800000000000,-0.461000000000000,-0.344000000000000,-0.267300000000000,-0.130100000000000,0.101800000000000,0.275800000000000,0.435300000000000,0.587300000000000,0.714500000000000,0.822400000000000,0.931600000000000,0.947800000000000,0.816000000000000,0.792900000000000,0.755900000000000,0.963100000000000,1.17030000000000,1.18560000000000,1.25400000000000,1.17920000000000,0.917500000000000,0.874500000000000,0.902700000000000,0.920900000000000,0.945500000000000,0.964300000000000,0.993100000000000,1.02320000000000,1.05850000000000,1.07520000000000,1.09870000000000,1.13130000000000,1.15020000000000,1.17780000000000,1.19740000000000,1.22560000000000,1.24040000000000,1.26130000000000,1.27980000000000,1.29600000000000,1.31230000000000,1.32730000000000,1.33900000000000,1.35050000000000,1.37540000000000,0.640500000000000];
C_d_data =  [0.118200000000000,0.108250000000000,0.0989900000000000,0.0950100000000000,0.0848100000000000,0.0767600000000000,0.0693900000000000,0.0372600000000000,0.0323800000000000,0.0309000000000000,0.0290200000000000,0.0307300000000000,0.0310200000000000,0.0303100000000000,0.0303200000000000,0.0318200000000000,0.0339800000000000,0.0420500000000000,0.0642300000000000,0.0805400000000000,0.100940000000000,0.0755000000000000,0.0499900000000000,0.0606200000000000,0.0719200000000000,0.0930200000000000,0.166600000000000,0.210620000000000,0.227070000000000,0.239890000000000,0.253120000000000,0.262840000000000,0.275800000000000,0.289170000000000,0.306300000000000,0.310520000000000,0.320860000000000,0.337900000000000,0.342490000000000,0.357490000000000,0.362430000000000,0.383000000000000,0.380240000000000,0.389400000000000,0.399590000000000,0.404220000000000,0.412450000000000,0.424790000000000,0.426300000000000,0.433130000000000,0.452570000000000,0.650100000000000];
for i = 1:1:length(r)
    %Columns 16 and 17 contain the AOA of the airfoil.
    alpha_rad(i) = Beta_rad(i) - phi_rad(i) - alpha_i_rad(i) + alpha_zl_rad(i);
    alpha_deg(i) = round(rad2deg(alpha_rad(i)),0);
    %Column 18 contains the Reynolds number for the blade elements
    Re(i) = (rho(alt_op)*V_R(i)*c(i))/mew(alt_op);
    %Columns 19 and 20 will contain the C_l and C_d values of the airfoil
    %section of the segment in question against the Alpha calculated apriori.
    index(i) = unique(find(alpha_data == alpha_deg(i)));
    C_l(i) = C_l_data(index(i));
    C_d(i) = C_d_data(index(i));
    %Columns 21 and 22 contain the differential lift and drag acting on element 
    d_L(i) = 0.5*rho(alt_op)*V_R(i)*V_R(i)*c(i)*C_l(i)*del_r;
    d_D(i) = 0.5*rho(alt_op)*V_R(i)*V_R(i)*c(i)*C_d(i)*del_r; 
end
for i = 1:1:no_elements
    d_T(i) = ((d_L(i)*cos(phi_rad(i)+alpha_i_rad(i))) - ...
             (d_D(i)*sin(phi_rad(i)+alpha_i_rad(i))));
    d_Q(i) = r(i)*((d_L(i)*sin(phi_rad(i)+alpha_i_rad(i)))+(d_D(i)*cos...
             (phi_rad(i)+alpha_i_rad(i))));
    d_P(i) = Omega_x_r(i)*((d_L(i)*sin(phi_rad(i)+alpha_i_rad(i)))+...
             (d_D(i)*cos(phi_rad(i)+alpha_i_rad(i))));
end

%Total values
Thrust_lbf = n_blades*sum(d_T)
Torque_ft_lbf = n_blades*sum(d_Q)
Power_lb_fts = n_blades*sum(d_P)
Power_hp = (n_blades*sum(d_P))/550

%Coefficients
C_P = Power_lb_fts/(rho(alt_op)*(n^3)*((Dia_prop/12)^5))
C_T = Thrust_lbf/(rho(alt_op)*(n^2)*((Dia_prop/12)^4))
C_Q = Torque_ft_lbf/(rho(alt_op)*(n^2)*((Dia_prop/12)^5))

%prop efficiency calculation
J = V_0_fts/(n*(Dia_prop/12))
eeta_p = J*(C_T/C_P)
